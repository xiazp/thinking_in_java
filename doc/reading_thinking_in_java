
chap3 操作符



chap5 初始化与清理
1. this 关键字只能在方法内部使用，表示对“调用方法的那个对象的引用”。
2. 构造器内可以用this调用一个构造器，但不能调用两个。
3.static方法的主要用途是在不需要创建对象的时候就能调用该方法。
static方法内部不能调用非static方法。将非static方法封装成static方法即可调用。
4. java对象的垃圾回收
（1）对象可能不被垃圾回收
（2）垃圾回收不等于析构
（3）垃圾回收只与内存有关
5.finalize的真正用途是 回收通过某种创建对象方式以外的方式为对象分配的存储空间。
6. java不允许创建局部对象，必须用new创建对象。
7. java 虚拟机的“自适应”垃圾回收技术
（1）停止-复制技术：暂停程序运行，然后将存活的对象从当前堆，复制到另一个堆。
（2）标记-清扫技术：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，并设一个
标记。全部标识gonzalez完成时，清理工作才开始。
8.在类的内部，变量定义的先后顺序决定了初始化的顺序，并且在类的任何方法被调用之前得到初始化。
9.static关键字不能用于局部变量，只能作用于域。
10.初始化顺序先是静态对象，而后是“非静态对象”。静态初始化只在class对象首次被加载的时候进行。

chap6
1.对类库进行权限控制，当类库的出现新的版本，类库消费者的代码可以不改变。
2.访问权限修饰词: public、protected、包访问权限（没有关键词）和private。
3.如何将类库构件置于包中？
A：包 是 库的单元。
4.一个java文件时一个编译单元，一个编译单元只有一个public类，编译单元的非public类在包外不可见。
5.package声明编译单元是某个类库的一部分
6.java的可运行程序是一组可以打包并压缩为一个java文档文件的.class文件。
7. java没有c的条件编译功能，但是import可以实现类似的功能。
8. 什么是包访问权限？
A：包中的所有类对该成员都有访问权限。
9. protected也提供包访问权限，即相同包内的其他类可以访问protected元素。

chap7 复用类
1.复用代码的两种方法：组合和继承。
2.每个类中都可以创建main方法。一个程序含有多个类，只有命令行调用的那个类的main()方法会被调用。
3.在静态方法中不能引用super。
4.对基类子对象初始化只有一种方法：在构造器中调用基类构造器来执行初始化。
5.基类在导出类构造器访问它之前，就完成了初始化。
6.调用基类构造器必须是导出类构造器中要做的第一件事
7.基类非默认构造类 需要在导出类的构造器中显示用super调用。
8. 类与类之间的第三种关系是代理，将类的某个成员类的成员再封装下。

9. 为什么要用代理关系处理类
A：

10. 使用组合和继承构造新类，类的基类首先初始化 然后才是类的成员对象

11. 类的清理： 可用try-finally结构，在finally的代码总是会被执行

12. @Override的作用是 确保重载的函数名正确

13. is-a (是一个)的关系用继承来表达，has-a(有一个)的关系用组合来表达。

14. protected 权限也提供包的访问权限

15.将导出类 转换成基类 称之为 向上转型。 

16. 如何选择组合和继承？  判断方法->是否需要从新类向基类进行向上转型。


17. 常量必须是基本数据类型，以final修饰，只能在定义时初始化。

18.使用final修饰对象，表示这个对象在定义时初始化指向一个对象，就无法再把它
指向另一个对象。

19. 既是static又是final的域只占一段不能改变的存储空间。

20. static final 和final的区别： final可在运行时构造器内初始化，static final只能再定义时初始化。

21. final 修饰参数，表示该参数不可改变其引用，如果是基本数据类型，则表示不可改变其值。

22. final方法 防止在继承类中被修改。所有的private隐形指定为final。

23. final 类不允许被继承。final类中的方法所有方法隐形指定为final

24. 构造器也是static方法，只是static 没有显示写出来

25. 类的加载：创建类的第一个对象，或是访问static域或static方法。

26. 类初始化的顺序: static域初始化->main->构造器->变量

Chap8 多态
多态通过分离 做什么 和 怎么 做， 从另一个角度把接口和实现分离开来。
1.向上转型：把对某个对象的引用视为对其基类型的引用
2.如何表现多态： 编写的代码只与基类打交道
3. 绑定： 将一个方法调用同一个方法主体关联起来
4.后期绑定：在运行时根据对象的类型进行绑定。必须要有在运行时能判断对象类型的机制。
5.设计良好的oop程序中，大多数方法都只与基类接口通信，这样程序是可扩展的
6.多态的缺陷
（1）只有非private 方法才可以覆盖。 private方法被自动认为是final 方法所以无法动态绑定
（2）方法调用是多态，域不是多态。
7.域的访问操作是在编译期由编译器解析。
8.为什么静态方法不是多态的，因为静态方法与类，而不是单个对象相关。
9.构造器是隐形的static声明，也不具有多态
10. 复杂对象调用构造器的调用顺序    <-重点知识
（1）基类构造器
（2）按声明顺序调用成员的初始化函数
（3）调用导出类构造器的主体
10. 通过组合和继承的方法创建新类，子对象通常都会留给垃圾回收器处理，不必担心对象的清理问题。
11. 共享对象依附到类时，必须调用addRef(), dispose()方法将跟踪引用数并决定何时执行清理。

12.构造器内部的多态方法的影响

13.初始化的实际过程
（1）在其他任何事物发生前，将分配给对象的存储空间初始化为二进制的0
（2）调用基类构造器
（3）按声明顺序调用成员的初始化方法
（4）调用导出类的构造器主体

14. 编写构造器的准则： 尽可能用简单的方法使对象进入正常状态；如果可以，避免调用其他方法。
能够安全调用的方法是基类的final方法

15. 协变返回类型： 导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型？？

16.用继承表达行为上的差异，并用字段表达状态上的差异

17. 向上转型是安全的，但会丢失具体的类型信息。向下转型不是安全的，但能获取类型信息。


chap9 接口
1.创建抽象类是希望通过这个通用接口操作一系列的类。
2.抽象类： 包含抽象方法的类，必须用abstract限定为抽象的
抽象方法：只有声明没有方法体。
3. 如果从一个抽象类中继承，并创建该新类的对象，那么必须为基类的所以抽象方法提供方法定义。
4.为什么要定义抽象类和抽象方法？
A： 使类的抽象性明确起来，并告诉用户和编译器打算怎么用它们。将公共方法沿着继承层次向上移动。
5.interface 产生一个完全抽象的类， 接口被用来建立类和类之间的协议。
接口包含域，这些域隐性声明为static 和 final。
接口中的方法隐性声明为public。
实现一个接口时，在接口中定义的方法必须实现为public
6.接口的实现类可以向上转型为 interface。

7.策略设计模式：创建一个能根据所传递的参数对象的不同而具有不同行为的方法。
策略就是传递进去的参数对象，包含了要执行的代码

8.适配器设计模式：接受你所拥有的接口，并产生你所需要的接口

9. 应该选择接口还是抽象类？
A：如果要创建不带任何方法定义和成员变量的基类，那就应该选择接口而不是抽象类。

10使用接口的核心原因：为了能够向上转型为多个基类。 其次是为了防止客户端程序员创建该类的对象。

11. 通过继承可扩展接口

12. 让方法接受接口类型是一种让任何类都可以对该方法进行适配的方式。

13. 接口中的任何域自动是static和final的，可以用来组建常量组。

14. 接口可以嵌套在类或者其他接口中。

15.控制框架 是用来解决响应事件的需求。主要用来响应事件的系统被称为事件驱动系统。



chap10 使用.this 与  .new
1. 内部类存在的合理性： 将逻辑相关的类组织在一起，并控制类的可视性。
2. 内部类拥有其外围类的所有元素的访问权限。
3. 迭代器设计模式： 用类封装数组，创建选择器操作数组。
1. 要用外部类的的对象 来创建内部类的对象 。
2. 要生成外部类对象的引用，可以使用外部类的名字后紧跟圆点和this。
3. 内部类对象 暗暗地连接一个外部类对象
4. 创建内部类对象，要在new的表达式提供对外部类对象的引用。
5. 内部类向上转型为其基类时，尤其是一个接口的时候，内部类就能够完全不可见，并且不可用。
6. 外部类不能访问内部类的域？？
7. 局部内部类：在方法的作用域创建的类。
8.为什么要使用内部类？
A： 内部类可以实现一个类型的接口并返回，创建并返回对其引用。创建一个辅助功能的类，但要隐藏起来。

9.在一个作用域内实现内部类的好处？
A：在作用域可用，作用域之前不可用。

10.匿名内部类是谁匿名了？
A： 匿名的是基类的子类匿名了。


11. 匿名内部类使用的外部对象是，必须是final修饰。 

12 匿名内部类没有构造器，它是用实例初始化。


chap11 持有对象
数组的成员是固定的，在程序中如果想添加更多的成员不可实现。 容器是可以动态地添加成员，
这正好解决了使用数组无法动态添加成员的问题。
容器分为两类Collection独立的元素序列 和 Map成组的元素序列。 List 和 Set 类都实现了 collection 接口。

1.List是一个泛型类， 创建对象时要穿件更具体的类 如ArrayList 或 LinkList。

2. Iterator 迭代器 是容器提供遍历容器元素的一个类。
ListIterator是Iterator的子类型，针对List类，提供更丰富的接口。
迭代器的add方法是在当前对象前 插入元素，插入后还是指向当前元素。

3. 容器的几种类型： list、 stack、 set、map、queue

4.LinkedLit具有stack所需的接口， 用组合方式 定义一个Stack的范型类，之所有用组合方式，
是因为stack只需要LinkedList的部分接口。

5.Set不保持重复的数据元素。

6. Map将一个对象映射到另一个对象

7.Queue 是先进先出的容器。 LinkedList支持 队列的行为，并实现了Queue接口。

8. 优先队列 声明下一个弹出的元素是最需要的元素。


Chap12
1.异常处理情形
A： 当抛出异常，首先堆上会创建异常对象。然后当前执行路径被终止，并弹出对异常对象的引用。
最后异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。

2.异常类的构造器：默认构造器和带string字符串的构造器

3.try 的内部是异常监控区域， catch的额内部是异常处理程序。

4.异常处理模型： 终止模型 和 恢复模型

5. 构建自定义异常
（1）方法后面可以添加异常说明，这表示该方法可能抛出 的异常。
（2）自定义的异常要在方法后面说明，非自定义异常不需要说明。

6.异常匹配原则： 根据代码的书写顺序寻找最近的处理方法。 例如继承异常类的基类和他的派生类对异常的处理。

7.异常可以被覆盖而丢失，所以如果不知道如何处理异常请勿捕获异常。
如果一个异常别抛出，另一个方法捕获该异常，并抛出另一个异常，第一个异常信息将丢失。

8.异常包装到RuntimeException可以不丢失原始信息。

9 getCause可以捕获并处理特定异常。

11.捕获所有异常：Exception 可捕获所有异常

12 finally 执行清理工作，即使在try中调用return，finally的语句也会执行。

13.finally中执行return， 可以用于丢弃异常。但是如果finally中抛出另一个异常
会导致第一个异常丢失。




chap13 字符串


chap14 类型信息
1.识别对象和类的信息： 一是“传统”RTTI，二是“反射”机制
什么是RTTI？ 在运行时识别一个对象的类型。

2.Class对象仅在需要的时候才被加载，static初始化在类加载时进行。

3.Class.forName 获取一个对象的引用，如果对象未被加载就加载它。

4.newInstance 创建类，该类必须要有默认构造器。

5.使用.class来创建对Class对象的引用，但是不会初始化该类。 引用static final变量 如果是一个编译期常量将不会引起
类的初始化，否则要初始化。

6.类的泛型引用： class<?> 定义一个非具体的类引用， class <? extends xx> 定义一个继承与xx的类的引用。

7.泛型语法用于class对象，用newInstance 将返回改类的具体类型。


chap15 泛型
1. 元组： 将一组对象打包存储在一个对象中，这样在方法的返回中可返回多个对象
2.





















