
chap3 操作符



chap5 初始化与清理
1. this 关键字只能在方法内部使用，表示对“调用方法的那个对象的引用”。
2. 构造器内可以用this调用一个构造器，但不能调用两个。
3.static方法的主要用途是在不需要创建对象的时候就能调用该方法。
static方法内部不能调用非static方法。将非static方法封装成static方法即可调用。
4. java对象的垃圾回收
（1）对象可能不被垃圾回收
（2）垃圾回收不等于析构
（3）垃圾回收只与内存有关
5.finalize的真正用途是 回收通过某种创建对象方式以外的方式为对象分配的存储空间。
6. java不允许创建局部对象，必须用new创建对象。
7. java 虚拟机的“自适应”垃圾回收技术
（1）停止-复制技术：暂停程序运行，然后将存活的对象从当前堆，复制到另一个堆。
（2）标记-清扫技术：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，并设一个
标记。全部标识gonzalez完成时，清理工作才开始。
8.在类的内部，变量定义的先后顺序决定了初始化的顺序，并且在类的任何方法被调用之前得到初始化。
9.static关键字不能用于局部变量，只能作用于域。
10.初始化顺序先是静态对象，而后是“非静态对象”。静态初始化只在class对象首次被加载的时候进行。

chap6
1.对类库进行权限控制，当类库的出现新的版本，类库消费者的代码可以不改变。
2.访问权限修饰词: public、protected、包访问权限（没有关键词）和private。
3.如何将类库构件置于包中？
A：包 是 库的单元。
4.一个java文件时一个编译单元，一个编译单元只有一个public类，编译单元的非public类在包外不可见。
5.package声明编译单元是某个类库的一部分
6.java的可运行程序是一组可以打包并压缩为一个java文档文件的.class文件。
7. java没有c的条件编译功能，但是import可以实现类似的功能。
8. 什么是包访问权限？
A：包中的所有类对该成员都有访问权限。
9. protected也提供包访问权限，即相同包内的其他类可以访问protected元素。

chap7 复用类
1.复用代码的两种方法：组合和继承。
2.每个类中都可以创建main方法。一个程序含有多个类，只有命令行调用的那个类的main()方法会被调用。
3.在静态方法中不能引用super。
4.对基类子对象初始化只有一种方法：在构造器中调用基类构造器来执行初始化。
5.基类在导出类构造器访问它之前，就完成了初始化。
6.调用基类构造器必须是导出类构造器中要做的第一件事
7.基类非默认构造类 需要在导出类的构造器中显示用super调用。
8. 类与类之间的第三种关系是代理，将类的某个成员类的成员再封装下。

9. 为什么要用代理关系处理类
A：

10. 使用组合和继承构造新类，类的基类首先初始化 然后才是类的成员对象

11. 类的清理： 可用try-finally结构，在finally的代码总是会被执行

12. @Override的作用是 确保重载的函数名正确

13. is-a (是一个)的关系用继承来表达，has-a(有一个)的关系用组合来表达。

14. protected 权限也提供包的访问权限

15.将导出类 转换成基类 称之为 向上转型。 

16. 如何选择组合和继承？  判断方法->是否需要从新类向基类进行向上转型。

17. 常量必须是基本数据类型，以final修饰，只能在定义时初始化。

18.使用final修饰对象，表示这个对象在定义时初始化指向一个对象，就无法再把它
指向另一个对象。

19. 既是static又是final的域只占一段不能改变的存储空间。

20. static final 和final的区别： final可在运行时构造器内初始化，static final只能再定义时初始化。

21. final 修饰参数，表示该参数不可改变其引用，如果是基本数据类型，则表示不可改变其值。

22. final方法 防止在继承类中被修改。所有的private隐形指定为final。

23. final 类不允许被继承。final类中的方法所有方法隐形指定为final

24. 构造器也是static方法，只是static 没有显示写出来

25. 类的加载：创建类的第一个对象，或是访问static域或static方法。

26. 类初始化的顺序: static域初始化->main->构造器->变量

Chap8 多态
多态通过分离 做什么 和 怎么 做， 从另一个角度把接口和实现分离开来。
1.向上转型：把对某个对象的引用视为对其基类型的引用
2.如何表现多态： 编写的代码只与基类打交道
3. 绑定： 将一个方法调用同一个方法主体关联起来
4.后期绑定：在运行时根据对象的类型进行绑定。必须要有在运行时能判断对象类型的机制。
5.设计良好的oop程序中，大多数方法都只与基类接口通信，这样程序是可扩展的
6.多态的缺陷
（1）只有非private 方法才可以覆盖。 private方法被自动认为是final 方法所以无法动态绑定
（2）方法调用是多态，域不是多态。
7.域的访问操作是在编译期由编译器解析。
8.为什么静态方法不是多态的，因为静态方法与类，而不是单个对象相关。
9.构造器是隐形的static声明，也不具有多态
10. 复杂对象调用构造器的调用顺序    <-重点知识
（1）基类构造器
（2）按声明顺序调用成员的初始化函数
（3）调用导出类构造器的主体
10. 通过组合和继承的方法创建新类，子对象通常都会留给垃圾回收器处理，不必担心对象的清理问题。
11. 共享对象依附到类时，必须调用addRef(), dispose()方法将跟踪引用数并决定何时执行清理。

12.构造器内部的多态方法的影响

13.初始化的实际过程
（1）在其他任何事物发生前，将分配给对象的存储空间初始化为二进制的0
（2）调用基类构造器
（3）按声明顺序调用成员的初始化方法
（4）调用导出类的构造器主体

14. 编写构造器的准则： 尽可能用简单的方法使对象进入正常状态；如果可以，避免调用其他方法。
能够安全调用的方法是基类的final方法

15. 协变返回类型： 导出类的被覆盖方法可以返回基类方法的返回类型的某种导出类型？？

16.用继承表达行为上的差异，并用字段表达状态上的差异

16. 向上转型是安全的，但会丢失具体的类型信息。向下转型不是安全的，但能获取类型信息。















