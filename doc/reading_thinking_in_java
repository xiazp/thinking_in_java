
chap3 操作符



chap5 初始化与清理
1. this 关键字只能在方法内部使用，表示对“调用方法的那个对象的引用”。
2. 构造器内可以用this调用一个构造器，但不能调用两个。
3.static方法的主要用途是在不需要创建对象的时候就能调用该方法。
static方法内部不能调用非static方法。将非static方法封装成static方法即可调用。
4. java对象的垃圾回收
（1）对象可能不被垃圾回收
（2）垃圾回收不等于析构
（3）垃圾回收只与内存有关
5.finalize的真正用途是 回收通过某种创建对象方式以外的方式为对象分配的存储空间。
6. java不允许创建局部对象，必须用new创建对象。
7. java 虚拟机的“自适应”垃圾回收技术
（1）停止-复制技术：暂停程序运行，然后将存活的对象从当前堆，复制到另一个堆。
（2）标记-清扫技术：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，并设一个
标记。全部标识gonzalez完成时，清理工作才开始。
8.在类的内部，变量定义的先后顺序决定了初始化的顺序，并且在类的任何方法被调用之前得到初始化。
9.static关键字不能用于局部变量，只能作用于域。
10.初始化顺序先是静态对象，而后是“非静态对象”。静态初始化只在class对象首次被加载的时候进行。

chap6
1.对类库进行权限控制，当类库的出现新的版本，类库消费者的代码可以不改变。
2.访问权限修饰词: public、protected、包访问权限（没有关键词）和private。
3.如何将类库构件置于包中？
A：包 是 库的单元。
4.一个java文件时一个编译单元，一个编译单元只有一个public类，编译单元的非public类在包外不可见。
5.package声明编译单元是某个类库的一部分
6.java的可运行程序是一组可以打包并压缩为一个java文档文件的.class文件。
7. java没有c的条件编译功能，但是import可以实现类似的功能。
8. 什么是包访问权限？
A：包中的所有类对该成员都有访问权限。
9. protected也提供包访问权限，即相同包内的其他类可以访问protected元素。

chap7 复用类
1.复用代码的两种方法：组合和继承。
2.每个类中都可以创建main方法。一个程序含有多个类，只有命令行调用的那个类的main()方法会被调用。
3.在静态方法中不能引用super。
4.对基类子对象初始化只有一种方法：在构造器中调用基类构造器来执行初始化。
5.基类在导出类构造器访问它之前，就完成了初始化。
6.调用基类构造器必须是导出类构造器中要做的第一件事
7.基类非默认构造类 需要在导出类的构造器中显示用super调用。
8. 类与类之间的第三种关系是代理，将类的某个成员类的成员再封装下。

9. 为什么要用代理关系处理类
A：

10. 使用组合和继承构造新类，类的基类首先初始化 然后才是类的成员对象

11. 类的清理： 可用try-finally结构，在finally的代码总是会被执行

12. @Override的作用是 确保重载的函数名正确

13. is-a (是一个)的关系用继承来表达，has-a(有一个)的关系用组合来表达。

14. protected 权限也提供包的访问权限

15.将导出类 转换成基类 称之为 向上转型。 

16. 如何选择组合和继承？  判断方法->是否需要从新类向基类进行向上转型。

17. 常量必须是基本数据类型，以final修饰，只能在定义时初始化。

18.使用final修饰对象，表示这个对象在定义时初始化指向一个对象，就无法再把它
指向另一个对象。

19. 既是static又是final的域只占一段不能改变的存储空间。

20. static final 和final的区别： final可在运行时构造器内初始化，static final只能再定义时初始化。

21. final 修饰参数，表示该参数不可改变其引用，如果是基本数据类型，则表示不可改变其值。

22. final方法 防止在继承类中被修改。所有的private隐形指定为final。

23. final 类不允许被继承。final类中的方法所有方法隐形指定为final

24. 构造器也是static方法，只是static 没有显示写出来

25. 类的加载：创建类的第一个对象，或是访问static域或static方法。

26. 类初始化的顺序: static域初始化->main->构造器->变量







